<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Teneo Leaderboards</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #FFF; font-family: sans-serif; }
    #rive-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; background: #FFF; }
  </style>
</head>
<body>
  <canvas id="rive-canvas"></canvas>
  
  <script src="https://unpkg.com/@rive-app/webgl2@2" crossorigin="anonymous"></script>

  <script>
    /* =======================================================================
       1.0 CONFIGURATION & ENDPOINTS
       ======================================================================= */
    
    // Endpoint for Banking Transactions (Writing data back to server)
    const BANKING_ENDPOINT = "https://script.google.com/macros/s/AKfycbxHWOPhhNTkykFDZJYERtZq4DxVGI8CrZYCiaOSH1-hTAcee828kPmAAXW-iCkI9QeBCQ/exec";

    // Data Source Configuration (Currently CSV-based)
    // FIX: Using './' ensures we look in the current repo folder, not the domain root.
    const PUB_HTML_URL = "./test_data.csv"; 
    const BASE_CSV_URL = "./test_data.csv?";
    const HOUSE_LOCAL_URL = "./house_data.csv?";
    const ATTENDANCE_LOCAL_URL = "./attendance_data.csv?"; 
    const HOMEWORK_LOCAL_URL = "./homework_data.csv?";
    
    // User Identity Fallback (For local testing/simulation)
    const SIMULATED_USER_LOGIN_ID = "nuha.ryklief@teneo.school";

    // Layout Constants (Matches Rive Artboard Structure)
    const HERO_SLOTS = 3;       // Top 3 Podium positions (Instances _1 to _3)
    const TABLE_SLOTS = 7;      // Scrollable list positions (Instances _4 to _10)
    const TABLE_START_SLOT = HERO_SLOTS + 1;


    /* =======================================================================
       2.0 GLOBAL STATE & INITIALIZATION
       ======================================================================= */
    
    const layout = new rive.Layout({ fit: rive.Fit.Layout, layoutScaleFactor: 1 });
    const canvas = document.getElementById('rive-canvas');
    
    // Rive Instances
    let r = null;           // Main Rive Application Instance
    let vm1 = null;         // Root View Model ('ViewModel1')
    let studentVM = null;   // Reference to the Student Panel VM
    let overviewVM = null;  // Reference to the Overview Panel VM

    // Internal Data Store
    // NOTE: Regardless of source (CSV or JSON), data must be mapped into this structure.
    const datasets = {
      points: { rows: [], pages: 1, map: new Map() },
      attendance: { rows: [], pages: 1, map: new Map() },
      homework: { rows: [], pages: 1, map: new Map() },
      houses: { rows: [], map: new Map() },
    };

    let active = 'points'; // Current View Mode (points | attendance | homework | houses)
    let pageIndex = 0;     // Current Pagination Index


    /* =======================================================================
       3.0 IDENTITY MANAGEMENT
       ======================================================================= */

    // Wraps the authentication provider's identity object.
    function getOktaIdentity() {
      return {
        firstName: window.firstName || "",
        lastName: window.lastName || "",
        email: (window.email || "").toLowerCase(),
        fullName: `${window.firstName || ""} ${window.lastName || ""}`.trim(),
      };
    }

    // Returns the canonical User ID for data lookups.
    function getPreferredUserId() {
      const { email } = getOktaIdentity();
      return (email || SIMULATED_USER_LOGIN_ID || "").toLowerCase();
    }

    async function waitForIdentity(timeoutMs = 3000) {
      const start = Date.now();
      while (!window.email && Date.now() - start < timeoutMs) {
        await new Promise(r => setTimeout(r, 50));
      }
    }


    /* =======================================================================
       4.0 HELPER UTILITIES
       ======================================================================= */

    // Resize logic for the Rive canvas
    function resize() { try { r?.resizeDrawingSurfaceToCanvas(); } catch { } }
    addEventListener('resize', resize);

    // Standard CSV Parser
    // NOTE: If switching to JSON API, this function can be deprecated.
    function parseCSV(text) {
      const rows = [];
      let row = [], field = "", inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') { field += '"'; i++; } else { inQuotes = false; }
          } else field += c;
        } else {
          if (c === '"') inQuotes = true;
          else if (c === ',') { row.push(field); field = ""; }
          else if (c === '\n') { row.push(field); rows.push(row); row = []; field = ""; }
          else if (c === '\r') { /* ignore */ }
          else field += c;
        }
      }
      row.push(field); rows.push(row);
      return rows;
    }

    // Fuzzy matcher for CSV headers (handles case and whitespace differences)
    function idxAny(headers, patterns) {
      const norm = s => String(s || '').toLowerCase().replace(/\./g, '').replace(/\s+/g, ' ').trim();
      const H = headers.map(h => norm(h));
      for (const p of patterns) {
        const target = norm(p);
        const i = H.indexOf(target);
        if (i !== -1) return i;
      }
      return -1;
    }

    // Safe Number Parsing (Strips commas for values like "1,200")
    function num(v) {
      if (v == null) return 0;
      const n = Number(String(v).replace(/[, ]+/g, ''));
      return isNaN(n) ? 0 : n;
    }

    // Loose Number Parsing (Extracts first valid number from string)
    function numLoose(v) {
      const m = String(v ?? '').match(/-?\d+(\.\d+)?/);
      return m ? Number(m[0]) : 0;
    }

    // Maps raw status strings to Rive State Machine triggers
    function normalizePointsStatus(s) {
      const v = String(s || '').trim().toLowerCase();
      if (v.startsWith('explorer')) return 'Explorer';
      if (v.startsWith('hero')) return 'Hero';
      if (v.startsWith('icon')) return 'Icon';
      if (v.startsWith('legend')) return 'Legend';
      return null;
    }

    function getPointsStatusForUser(userId) {
      const id = String(userId || '').toLowerCase();
      const i = datasets.points?.map?.get(id);
      const row = (i != null) ? datasets.points.rows[i] : null;
      return normalizePointsStatus(row?.status);
    }

    // Sheet GID extraction (Specific to Google Sheets publishing)
    function findGidForSheet(html, sheetName) {
      const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const nameRe = esc(String(sheetName).trim());
      let m = new RegExp(`href="[^"]*?gid=(\\d+)[^"]*"[^>]*>\\s*${nameRe}\\s*<`, 'i').exec(html);
      if (m) return m[1];
      m = new RegExp(`data-gid="(\\d+)"[^>]*>\\s*${nameRe}\\s*<`, 'i').exec(html);
      if (m) return m[1];
      const near = new RegExp(`${nameRe}[\\s\\S]{0,200}?gid=(\\d+)`, 'i').exec(html);
      if (near) return near[1];
      return null;
    }

    // Pagination Calculator
    function computeTotalPages(totalRows) {
      const remaining = Math.max(0, totalRows - HERO_SLOTS);
      return Math.max(1, Math.ceil(remaining / TABLE_SLOTS));
    }

    // Fetch Wrapper (Handles Auth Headers if needed)
    async function fetchCsvOrThrow(url) {
      const res = await fetch(url, {
        credentials: "include",
        redirect: "manual",
        headers: { "X-Requested-With": "fetch", "X-Okta-Email": getPreferredUserId()}
      });
      if (res.type === "opaqueredirect" || res.status === 0 || res.status === 302 || res.status === 401) {
        throw new Error("[Sheets] Not authenticated (SAML). Reload the page to sign in.");
      }
      if (!res.ok) {
        throw new Error(`[Sheets] HTTP ${res.status} while fetching ${url}`);
      }
      return res.text();
    }

    // Retrieves a specific user's row from the dataset
    function pickRowByUserStrict(ds, userId) {
      if (!ds || !userId) return null;
      if (ds.map && ds.map.has(userId)) {
        return ds.rows[ds.map.get(userId)];
      }
      return null;
    }

    // Generates a default/empty row for users not found in the dataset
    function synthesizeUserRow(userId) {
      const { fullName } = getOktaIdentity();
      const fromPoints = pickRowByUserStrict(datasets.points, userId);
      const name = fromPoints?.name || (fullName || "Student");

      return {
        i: -1,
        position: 0,
        userId: userId,
        email: userId,
        name,
        studentNumber: "",
        curriculum: "",
        grade: "",
        house: "",
        // REMOVED: manualPoints: 0,
        orientation: "",
        pointsPending: 0,
        pointsBanked: 0,
        pointsLost: 0,
        csvPosition: 0,
        lessonAttendance: 0,
        moduleCompletion: 0,
        assessmentSubmission: 0,
        homework: 0,
        score: 0,
        change: 0,
        attendanceLevel: 0,
        attendanceDay: 0,
        homeworkLevel: 0,
        homeworkDay: 0,
        status: ''
      };
    }

    // Date & Week Calculator for the Overview Panel
    function getCurrentWeekInfo() {
      const now = new Date();
      // Calculate ISO Week Number
      const d = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
      d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      const weekNum = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);

      // Calculate Range (Monday - Sunday)
      const curr = new Date(); 
      const currentDay = curr.getDay(); // 0=Sun, 1=Mon...
      const distanceToMon = currentDay === 0 ? -6 : 1 - currentDay; 
      
      const monday = new Date(curr);
      monday.setDate(curr.getDate() + distanceToMon);
      
      const sunday = new Date(monday);
      sunday.setDate(monday.getDate() + 6);

      const fmt = (dt) => {
        const day = dt.getDate();
        const month = dt.toLocaleString('en-GB', { month: 'long' });
        const suffix = (day % 10 == 1 && day != 11) ? "st" : 
                       (day % 10 == 2 && day != 12) ? "nd" : 
                       (day % 10 == 3 && day != 13) ? "rd" : "th";
        return `${day}${suffix} ${month}`;
      };

      return {
        number: weekNum,
        range: `${fmt(monday)} - ${fmt(sunday)}`
      };
    }


    /* =======================================================================
       5.0 DATA MAPPING LAYER (Parsers)
       ======================================================================= */
    
    // NOTE TO DEVELOPER: 
    // These functions map the external data source (currently CSV) to the internal 
    // Javascript object structure required by the Rive integration.
    // If switching to a JSON API, ensure the returned objects match the schema defined below.

    // 5.1 Parse Student Points & General Stats
    function parsePoints(csvText) {
      const rows = parseCSV(csvText).filter(r => r.length && r.some(c => (c || '').trim() !== ''));
      if (!rows.length) return [];
      const headersRaw = rows[0].map(h => (h || '').trim());

      // Header Mapping
      const idI = idxAny(headersRaw, ['user_login_id', 'Student_Number']); 
      const nameI = idxAny(headersRaw, ['Student Name', 'Student_Name']);
      const stdNumI = idxAny(headersRaw, ['student_number']);
      const currI = idxAny(headersRaw, ['curriculum']);
      const gradeI = idxAny(headersRaw, ['grade']);
      const houseI = idxAny(headersRaw, ['House']);
      const orientI = idxAny(headersRaw, ['Orientation_Completion']);
      const curPosI = idxAny(headersRaw, ['Current Position']);
      const changeI = idxAny(headersRaw, ['Change', 'Rank_Change']);
      
      const lessonI = idxAny(headersRaw, ['Lesson Attendance']);
      const assessI = idxAny(headersRaw, ['Assessment Submission']);
      const moduleI = idxAny(headersRaw, ['Module Completion']);
      const hwCompI = idxAny(headersRaw, ['homework_completion']);
      // REMOVED: ManualPoints index search
      
      const pendingI = idxAny(headersRaw, ['PointsPending', 'Points_Pending']);
      const bankedI = idxAny(headersRaw, ['PointsBanked', 'Points_Banked']);
      const lostI = idxAny(headersRaw, ['PointsLost', 'Points_Lost']);
      const statusI = idxAny(headersRaw, ['Status']);

      const out = rows.slice(1).map((r, i) => {
        const userId = String(r[idI] || '').trim().toLowerCase();
        if (!userId) return null;
        const name = String(r[nameI] || '').trim();

        // Numeric sanitization (Handling commas)
        const lesson = lessonI !== -1 ? num(r[lessonI]) : 0;
        const assess = assessI !== -1 ? num(r[assessI]) : 0;
        const module = moduleI !== -1 ? num(r[moduleI]) : 0;
        const hwcomp = hwCompI !== -1 ? num(r[hwCompI]) : 0;
        // REMOVED: ManualPoints parsing
        
        const change = changeI !== -1 ? numLoose(r[changeI]) : 0; 
        const rawCsvPos = curPosI !== -1 ? numLoose(r[curPosI]) : 0;

        // Score Calculation
        const pPending = pendingI !== -1 ? num(r[pendingI]) : 0;
        const pBanked = bankedI !== -1 ? num(r[bankedI]) : 0;
        const pLost = lostI !== -1 ? num(r[lostI]) : 0;
        const score = pPending + pBanked + pLost;

        return {
          i,
          userId,
          email: userId,
          name,
          firstName: name,
          studentNumber: stdNumI !== -1 ? String(r[stdNumI] || '') : "",
          curriculum: currI !== -1 ? String(r[currI] || '') : "",
          grade: gradeI !== -1 ? String(r[gradeI] || '') : "",
          house: houseI !== -1 ? String(r[houseI] || '') : "",
          orientation: orientI !== -1 ? String(r[orientI] || '') : "",
          
          lessonAttendance: lesson,
          assessmentSubmission: assess,
          moduleCompletion: module,
          homework: hwcomp,
          // REMOVED: manualPoints property
          
          pointsPending: pPending,
          pointsBanked: pBanked,
          pointsLost: pLost,
          score,
          change,
          csvPosition: rawCsvPos,
          status: String((statusI !== -1 ? r[statusI] : '') || '').trim()
        };
      }).filter(Boolean);

      return out;
    }

    // 5.2 Parse Streak Data (Attendance & Homework)
    function parseStreaks(csvText, kind) {
      const rows = parseCSV(csvText).filter(r => r.length && r.some(c => (c || '').trim() !== ''));
      if (!rows.length) return [];
      const headersRaw = rows[0].map(h => (h || '').trim());

      const idI = idxAny(headersRaw, ['user_login_id']);
      const nameI = idxAny(headersRaw, ['Student Name']);
      const currI = idxAny(headersRaw, ['curriculum']);
      const gradeI = idxAny(headersRaw, ['grade']);
      const daysI = idxAny(headersRaw, ['No.of streak days', 'No. of Streak Days', 'No of Streak Days']);
      const levelI = idxAny(headersRaw, ['Level']);
      const statusI = idxAny(headersRaw, ['Status']);
      const posI = idxAny(headersRaw, ['Position']);

      const out = rows.slice(1).map((r, i) => {
        const userId = String(r[idI] || '').trim().toLowerCase();
        if (!userId) return null;
        const name = String(r[nameI] || '').trim();
        const level = levelI !== -1 ? numLoose(r[levelI]) : 0;
        const days = daysI !== -1 ? numLoose(r[daysI]) : 0;
        const pos = posI !== -1 ? numLoose(r[posI]) : undefined;
        const status = String((statusI !== -1 ? r[statusI] : '') || '').trim();

        const row = {
          i,
          userId,
          email: userId,
          name,
          curriculum: currI !== -1 ? String(r[currI] || '') : "",
          grade: gradeI !== -1 ? String(r[gradeI] || '') : "",
          score: 0,
          change: 0,
          status,
          position: pos
        };

        if (kind === 'attendance') {
          row.attendanceLevel = level;
          row.attendanceDay = days;
        } else {
          row.homeworkLevel = level;
          row.homeworkDay = days;
        }
        return row;
      }).filter(Boolean);

      return out;
    }

    // 5.3 Parse House Data
    function parseHouses(csvText) {
      const rows = parseCSV(csvText).filter(r => r.length && r.some(c => (c || '').trim() !== ''));
      if (!rows.length) return [];
      const headersRaw = rows[0].map(h => (h || '').trim());

      // Identification Headers
      const nameI = idxAny(headersRaw, ['HouseName']);
      const pointsI = idxAny(headersRaw, ['HousePoints']);
      const posI = idxAny(headersRaw, ['HousePosition']);

      // Statistics Headers
      const lessonI = idxAny(headersRaw, ['Lesson Attendance']);
      const moduleI = idxAny(headersRaw, ['Module Completion']);
      const hwI = idxAny(headersRaw, ['homework_completion']);
      const assessI = idxAny(headersRaw, ['Assessment Submission']);
      // REMOVED: Manual_Points index search
      const orientI = idxAny(headersRaw, ['Orientation_Completion']);

      const out = rows.slice(1).map((r, i) => {
        const name = nameI !== -1 ? String(r[nameI] || '').trim() : "";
        if (!name) return null;

        const rawPos = posI !== -1 ? String(r[posI] || '') : "";
        const posNum = parseInt(rawPos) || (i + 1); 

        return {
          userId: name.toLowerCase(), 
          name: name, 
          
          score: pointsI !== -1 ? num(r[pointsI]) : 0, 
          position: posNum,
          positionStr: rawPos,

          // Mapped Statistics
          lessonAttendance: lessonI !== -1 ? num(r[lessonI]) : 0,
          moduleCompletion: moduleI !== -1 ? num(r[moduleI]) : 0,
          homework: hwI !== -1 ? num(r[hwI]) : 0,
          assessmentSubmission: assessI !== -1 ? num(r[assessI]) : 0,
          // REMOVED: manualPoints property
          orientation: orientI !== -1 ? String(r[orientI] || '') : "0%"
        };
      }).filter(Boolean);

      // Enforce Sorting (1st to 4th)
      out.sort((a, b) => a.position - b.position);

      return out;
    }


    /* =======================================================================
       6.0 DATA INGESTION LAYER
       ======================================================================= */

    async function preloadAllThree() {
      
      // --- TODO: DEVELOPER INTERVENTION REQUIRED ---
      // This section currently fetches data from public CSVs.
      // Replace the logic below with `fetch` calls to your Secure API Endpoints.
      // ---------------------------------------------

      // 1. Fetch Raw Data (Currently CSV)
      const resHtml = await fetch(PUB_HTML_URL, { credentials: "include", redirect: "manual", headers: { "X-Requested-With": "fetch" } });
      if (resHtml.type === "opaqueredirect" || resHtml.status === 0 || resHtml.status === 302 || resHtml.status === 401) {
        throw new Error("[Auth] Not authenticated (SAML). Reload to sign in.");
      }
      const html = await resHtml.text();

      // Extract Sheet GIDs (Specific to Google Sheets implementation)
      const gidPoints = findGidForSheet(html, 'Points') ?? 0;
      const gidAttendance = findGidForSheet(html, 'Attendance Streaks') ?? 0;
      const gidHomework = findGidForSheet(html, 'Homework Streaks') ?? 0;
      const gidHouse = findGidForSheet(html, 'House') ?? 0; 

      const isLocal = BASE_CSV_URL.includes("test_data");
      const pointsUrl = isLocal ? BASE_CSV_URL : `${BASE_CSV_URL}&gid=${gidPoints}`;
      const attendUrl = isLocal ? ATTENDANCE_LOCAL_URL : `${BASE_CSV_URL}&gid=${gidAttendance}`;
      const homeUrl   = isLocal ? HOMEWORK_LOCAL_URL   : `${BASE_CSV_URL}&gid=${gidHomework}`;
      const houseUrl  = isLocal ? HOUSE_LOCAL_URL      : `${BASE_CSV_URL}&gid=${gidHouse}`;

      const [csvPoints, csvAttend, csvHome, csvHouse] = await Promise.all([
        fetchCsvOrThrow(pointsUrl),
        fetchCsvOrThrow(attendUrl),
        fetchCsvOrThrow(homeUrl),
        fetchCsvOrThrow(houseUrl)
      ]);

      // 2. Parse Data
      let rowsPoints = parsePoints(csvPoints);
      let rowsAttend = parseStreaks(csvAttend, 'attendance');
      let rowsHome   = parseStreaks(csvHome, 'homework');
      let rowsHouse  = parseHouses(csvHouse);

      datasets.houses.rows = rowsHouse;
      datasets.houses.map = new Map(rowsHouse.map(r => [r.name.toLowerCase(), r]));

      // 3. Apply Segmentation/Filtering (Grade & Curriculum)
      const myId = getPreferredUserId();
      const myRow = rowsPoints.find(r => r.userId === myId);

      if (myRow) {
          const myGrade = (myRow.grade || '').trim().toLowerCase();
          const myCurr = (myRow.curriculum || '').trim().toLowerCase();
          console.log(`[SEGMENTATION] Filtering for: ${myCurr} / ${myGrade}`);

          const isMatch = (r) => {
              const g = (r.grade || '').trim().toLowerCase();
              const c = (r.curriculum || '').trim().toLowerCase();
              return g === myGrade && c === myCurr;
          };

          rowsPoints = rowsPoints.filter(isMatch);
          rowsAttend = rowsAttend.filter(isMatch);
          rowsHome   = rowsHome.filter(isMatch);
      }

      datasets.points.rows = rowsPoints;
      datasets.attendance.rows = rowsAttend;
      datasets.homework.rows = rowsHome;

      // 4. Sort & Rank Logic
      for (const key of Object.keys(datasets)) {
        if (key === 'houses') continue;
        const ds = datasets[key];

        if (key === 'points') {
          ds.rows.sort((a, b) => ((b.score ?? 0) - (a.score ?? 0)) || (a.i - b.i));
        } else if (key === 'attendance') {
          ds.rows.sort((a, b) =>
            ((b.attendanceLevel ?? 0) - (a.attendanceLevel ?? 0)) ||
            ((b.attendanceDay ?? 0) - (a.attendanceDay ?? 0)) || (a.i - b.i)
          );
        } else if (key === 'homework') {
          ds.rows.sort((a, b) =>
            ((b.homeworkLevel ?? 0) - (a.homeworkLevel ?? 0)) ||
            ((b.homeworkDay ?? 0) - (a.homeworkDay ?? 0)) || (a.i - b.i)
          );
        }

        for (let i = 0; i < ds.rows.length; i++) {
            if (i === 0) {
                ds.rows[i].position = 1; 
            } else {
                const prev = ds.rows[i - 1];
                const curr = ds.rows[i];
                let isTied = false;

                if (key === 'points') isTied = (curr.score === prev.score);
                else if (key === 'attendance') isTied = (curr.attendanceLevel === prev.attendanceLevel) && (curr.attendanceDay === prev.attendanceDay);
                else if (key === 'homework') isTied = (curr.homeworkLevel === prev.homeworkLevel) && (curr.homeworkDay === prev.homeworkDay);

                ds.rows[i].position = isTied ? prev.position : i + 1;
            }
        }
        
        ds.pages = computeTotalPages(ds.rows.length);
        ds.map = new Map(ds.rows.map((row, i) => [row.userId, i]));
      }
    }


    /* =======================================================================
       7.0 RIVE INITIALIZATION & EVENT LISTENERS
       ======================================================================= */

    r = new rive.Rive({
      src: 'assets/leaderboard.riv', // <--- Reverted to original filename (Option B)
      canvas,
      artboard: 'Dashboard',
      stateMachines: ['State Machine 1'],
      autoplay: true,
      layout,
      autoBind: true,
      onLoad: async () => {
        resize();

        // 7.1 View Model Resolution
        vm1 = (typeof r.viewModelInstance === 'function' ? r.viewModelInstance('ViewModel1') : null) ||
              r.viewModelInstance || r.contents?.viewModel?.('ViewModel1')?.instance?.();

        overviewVM = (typeof r.viewModelInstance === 'function' ? r.viewModelInstance('Overview') : null) ||
                     vm1?.viewModel?.('Overview') || vm1?.getViewModel?.('Overview') ||
                     r.contents?.viewModel?.('Overview')?.instance?.();

        studentVM = resolveStudentVM(r, vm1);

        if (!vm1) return;
        setLoaded(false);

        // 7.2 Event Listener (Pagination & Banking Logic)
        r.on?.(rive.EventType.RiveEvent, (evt) => {
          const ev = evt?.data;
          if (!ev || ev.type !== rive.RiveEventType.General) return;

          // Pagination
          if (ev.name === 'PageForward') { goPage(+1); return; }
          if (ev.name === 'PageBack') { goPage(-1); return; }

          // Banking (Writing Points back to Server)
          if (ev.name === 'Banked') {
             console.log("üí∞ [ACTION] Banked button clicked!");

             const pendingProp = overviewVM?.number?.('PointsPending') ?? overviewVM?.getNumber?.('PointsPending');
             const moneyProp   = overviewVM?.number?.('MoneyValue')    ?? overviewVM?.getNumber?.('MoneyValue');
             const bankedProp  = overviewVM?.number?.('BankedPoints')  ?? overviewVM?.getNumber?.('BankedPoints');

             if (!bankedProp) console.warn("‚ö†Ô∏è Could not find Rive input 'BankedPoints'.");

             const currentPending = pendingProp ? pendingProp.value : 0;
             const currentBanked  = bankedProp  ? bankedProp.value  : 0;

             const newTotalPoints = currentBanked + currentPending;
             const newTotalMoney = Number((newTotalPoints * 0.01).toFixed(2));

             console.log(`üßÆ Math: Pending (${currentPending}) + Banked (${currentBanked}) = New (${newTotalPoints}) | Money: ${newTotalMoney}`);

             if (bankedProp)  bankedProp.value  = newTotalPoints;  
             if (moneyProp)   moneyProp.value   = newTotalMoney;   
             if (pendingProp) pendingProp.value = 0;               

             const userEmail = getPreferredUserId(); 
             if (currentPending <= 0) return;
             
             const moneyEarnedThisTransaction = Number((currentPending * 0.01).toFixed(2));
             const weekNum = getCurrentWeekInfo().number; 

             fetch(BANKING_ENDPOINT, {
                 method: "POST", mode: "no-cors", headers: { "Content-Type": "text/plain" },
                 body: JSON.stringify({ 
                     email: userEmail, 
                     points: currentPending, 
                     moneyEarned: moneyEarnedThisTransaction,
                     week: `Week ${weekNum}`
                 })
             })
             .then(() => console.log(`‚úÖ Bank request sent for Week ${weekNum}!`))
             .catch(err => console.error("‚ùå Banking failed:", err));
             return; 
          }
        });

        // 7.3 Data Loading
        try {
          await preloadAllThree();
        } catch (err) {
          console.error(err?.message || err);
          setLoaded(false);
          try {
            const errStr = vm1?.string?.('ErrorMessage') || vm1?.getString?.('ErrorMessage');
            if (errStr) errStr.value = String(err?.message || 'Failed to load data.');
          } catch { }
          return;
        }

        // 7.4 Start Application
        writeOverview();
        
        // --- preLaunch Date Check ---
        const preLaunchProp = vm1?.boolean?.('preLaunch') ?? vm1?.getBoolean?.('preLaunch');
        if (preLaunchProp) {
            // Target: Feb 2, 2026 (Month is 0-indexed)
            const targetDate = new Date(2025, 1, 2); 
            const now = new Date();
            
            if (now >= targetDate) {
                console.log("üöÄ Launch Date Reached: Setting preLaunch to TRUE.");
                preLaunchProp.value = true;
            } else {
                preLaunchProp.value = false;
            }
        }

        // --- NEW: Dev Mode Listener ---
        // Type "devmode" on your keyboard to force launch
        let keyBuffer = "";
        window.addEventListener('keydown', (e) => {
            keyBuffer += e.key.toLowerCase();
            // Keep buffer short
            if (keyBuffer.length > 20) keyBuffer = keyBuffer.slice(-20);
            
            if (keyBuffer.endsWith("devmode")) {
                 console.log("üë®‚Äçüíª Dev Mode Activated: Bypassing Pre-launch!");
                 if (preLaunchProp) preLaunchProp.value = true;
            }
        });
        // ------------------------------

        const mode0 = readModeFromBooleans(false);
        setMode(mode0, { resetPage: true });
        setLoaded(true);
        console.log("[READY] Leaderboard loaded");

        let lastMode = mode0;
        setInterval(() => {
          const m = readModeFromBooleans(false);
          if (m !== lastMode) {
            lastMode = m;
            setMode(m, { resetPage: true });
          }
        }, 300);
      }
    });

    // Helper to find the Student Panel VM in various runtime hierarchies
    function resolveStudentVM(r, vm1) {
      const candidates = [];
      try { const v = vm1?.viewModel?.('Student') || vm1?.getViewModel?.('Student'); if (v) candidates.push(['vm1->Student', v]); } catch { }
      try { const v = (typeof r.viewModelInstance === 'function' ? r.viewModelInstance('Student') : r.viewModelInstance); if (v) candidates.push(['r.viewModelInstance(Student)', v]); } catch { }
      try { const v = r.contents?.viewModel?.('Student')?.instance?.(); if (v) candidates.push(['contents->Student.instance()', v]); } catch { }
      try { const ui = vm1?.viewModel?.('UserInfo') || vm1?.getViewModel?.('UserInfo'); const v = ui?.viewModel?.('Student') || ui?.getViewModel?.('Student'); if (v) candidates.push(['vm1->UserInfo->Student', v]); } catch { }
      const hit = candidates.find(([_, inst]) => !!inst) || null;
      return hit ? hit[1] : null;
    }


    /* =======================================================================
       8.0 VIEW MODEL LOGIC (DATA BINDING)
       ======================================================================= */

    // 8.1 Write Overview Panel Data
    function writeOverview() {
      if (!overviewVM) return;

      const preferUserId = getPreferredUserId();
      let p = pickRowByUserStrict(datasets.points, preferUserId);
      let a = pickRowByUserStrict(datasets.attendance, preferUserId);
      let h = pickRowByUserStrict(datasets.homework, preferUserId);

      if (!p) p = synthesizeUserRow(preferUserId);
      if (!a) a = { attendanceLevel: 0, attendanceDay: 0 }; 
      if (!h) h = { homeworkLevel: 0, homeworkDay: 0 };

      // --- HOUSE LOOKUP ---
      // 1. Identify the User's House
      const userHouseName = (p.house || '').trim();
      // 2. Find that House's data object
      const userHouseData = datasets.houses.map.get(userHouseName.toLowerCase());

      // --- STRINGS ---
      const setStr = (name, val) => {
          const prop = overviewVM.string?.(name) ?? overviewVM.getString?.(name);
          if (prop) prop.value = String(val || '');
      };

      setStr('Student_Number', p.studentNumber);
      setStr('Curriculum', p.curriculum);
      setStr('Grade', p.grade);
      setStr('OrientationCompletion', p.orientation);
      setStr('StudentName', p.name);
      setStr('StudentFirstName', (p.name || '').trim().split(/\s+/)[0] || '');
      
      setStr('HouseName', userHouseName);
      setStr('HousePosition', userHouseData ? userHouseData.positionStr : "");

      if (userHouseData) {
         setStr('House_OrientationCompletion', userHouseData.orientation);
      }

      // --- NUMBERS ---
      const setNum = (name, val) => {
          const prop = overviewVM.number?.(name) ?? overviewVM.getNumber?.(name);
          if (prop) prop.value = Number(val || 0);
      };

      setNum('LessonAttendance', p.lessonAttendance);
      setNum('ModuleCompletion', p.moduleCompletion);
      setNum('Homework', p.homework);
      setNum('AssessmentSubmission', p.assessmentSubmission);
      // REMOVED: ManualPoints
      
      setNum('PointsPending', p.pointsPending);
      setNum('BankedPoints', p.pointsBanked); 
      setNum('PointsLost', p.pointsLost);
      setNum('MoneyValue', Number((p.pointsBanked * 0.01).toFixed(2)));

      if (userHouseData) {
          setNum('House_LessonAttendance', userHouseData.lessonAttendance);
          setNum('House_ModuleCompletion', userHouseData.moduleCompletion);
          setNum('House_HomeworkCompletion', userHouseData.homework);
          setNum('House_AssessmentSubmission', userHouseData.assessmentSubmission);
          // REMOVED: House_ManualPoints
          
          setNum('HousePoints', userHouseData.score);
      } else {
          setNum('HousePoints', 0);
          setNum('House_LessonAttendance', 0);
          setNum('House_ModuleCompletion', 0);
          setNum('House_HomeworkCompletion', 0);
          setNum('House_AssessmentSubmission', 0);
      }

      setStr('AttendanceLevel', String(a.attendanceLevel || 0)); 
      setNum('AttendanceStreak', a.attendanceDay);
      setStr('HomeworkLevel', String(h.homeworkLevel || 0));
      setNum('HomeworkStreak', h.homeworkDay);

      // --- DATE & WEEK UPDATE ---
      const weekInfo = getCurrentWeekInfo();
      setNum('WeekNumber', weekInfo.number);
      setStr('Dates', weekInfo.range);

      // --- Longest Streak & Enums ---
      const attendStreak = a.attendanceDay || 0;
      const homeStreak   = h.homeworkDay || 0;
      let longestVal = 0;
      let longestCat = "";

      if (attendStreak >= homeStreak) {
          longestVal = attendStreak;
          longestCat = "Attendance";
      } else {
          longestVal = homeStreak;
          longestCat = "Homework";
      }

      setNum('LongestStreak', longestVal);
      setStr('LongestStreakCat', longestCat);

      const ps1 = overviewVM.enum?.('PointsStatusEnum1') ?? overviewVM.getEnum?.('PointsStatusEnum1');
      if (ps1) {
          try { ps1.value = normalizePointsStatus(p.status) ?? null; } catch { }
      }
      
      const levelEnum = overviewVM.enum?.('Level') ?? overviewVM.getEnum?.('Level');
      if (levelEnum) {
        let lvl = 'Default';
        if (datasets.points?.map?.has(preferUserId)) {
             if (p.change > 0) lvl = 'Up';
             else if (p.change < 0) lvl = 'Reset';
             else lvl = 'Neutral';
        }
        try { levelEnum.value = lvl; } catch { }
      }
    }

    // 8.2 Render Helper: Visibility
    function setEntryVisible(entryVM, show) {
      const vis = entryVM?.boolean?.('Visible') ?? entryVM?.getBoolean?.('Visible');
      if (vis && 'value' in vis) vis.value = !!show;
    }

    // 8.3 Core Rendering Logic
    function renderTable(rows) {
      if (!vm1) {
          console.warn("Main ViewModel (vm1) not loaded yet.");
          return;
      }

      // CASE A: HOUSE MODE
      if (active === 'houses') {
         const houseRows = datasets.houses.rows; 
         
         // 1. Update List (House1...House4)
         for (let i = 1; i <= 4; i++) {
            const childName = `House${i}`;
            const houseVM = vm1.viewModel ? vm1.viewModel(childName) : vm1.getViewModel(childName);
            if (!houseVM) continue;
            writeHouseEntry(houseVM, houseRows[i - 1]);
         }

         // 2. Update Podium (_1..._3) with Top 3 Houses
         for (let i = 1; i <= HERO_SLOTS; i++) {
             const vmName = `_${i}`;
             let heroVM = vm1.viewModel ? vm1.viewModel(vmName) : vm1.getViewModel(vmName);
             if (!heroVM) {
                 const overviewVM = vm1.viewModel ? vm1.viewModel('Overview') : vm1.getViewModel('Overview');
                 if (overviewVM) heroVM = overviewVM.viewModel ? overviewVM.viewModel(vmName) : overviewVM.getViewModel(vmName);
             }
             if (heroVM) {
                 writeEntry(heroVM, houseRows[i - 1], i); 
             }
         }
         return; 
      }

      // CASE B: STUDENT MODE
      
      // 1. Update Podium (Hero Slots 1-3)
      for (let i = 1; i <= HERO_SLOTS; i++) {
         const vmName = `_${i}`;
         let heroVM = vm1.viewModel ? vm1.viewModel(vmName) : vm1.getViewModel(vmName);
         if (!heroVM) {
             const overviewVM = vm1.viewModel ? vm1.viewModel('Overview') : vm1.getViewModel('Overview');
             if (overviewVM) heroVM = overviewVM.viewModel ? overviewVM.viewModel(vmName) : overviewVM.getViewModel(vmName);
         }
         if (heroVM) {
             const row = rows[i - 1]; 
             writeEntry(heroVM, row, i); 
         }
      }

      // 2. Update Scrollable List (Slots 4-10)
      const firstIdx = HERO_SLOTS + pageIndex * TABLE_SLOTS;
      const remaining = Math.max(0, rows.length - HERO_SLOTS - pageIndex * TABLE_SLOTS);
      const rowsThisPage = Math.min(TABLE_SLOTS, remaining);

      for (let j = 0; j < rowsThisPage; j++) {
        const slot = TABLE_START_SLOT + j; 
        const vmName = `_${slot}`; 
        const entryVM = vm1.viewModel ? vm1.viewModel(vmName) : vm1.getViewModel(vmName);
        if (!entryVM) continue;

        const row = rows[firstIdx + j];
        const fallbackPos = HERO_SLOTS + (pageIndex * TABLE_SLOTS) + j + 1;
        
        setEntryVisible(entryVM, true);
        writeEntry(entryVM, row, fallbackPos);
      }
      
      // Clear empty rows
      for (let j = rowsThisPage; j < TABLE_SLOTS; j++) {
        const slot = TABLE_START_SLOT + j;
        const vmName = `_${slot}`;
        const entryVM = vm1.viewModel ? vm1.viewModel(vmName) : vm1.getViewModel(vmName);
        if (!entryVM) continue;
        setEntryVisible(entryVM, false);
        writeEntry(entryVM, null, 0);
      }
    }
    
    // 8.4 Data Writer: Houses
    function writeHouseEntry(houseVM, row) {
        if (!houseVM) return;

        const setS = (propName, val) => {
            const p = houseVM.string?.(propName) ?? houseVM.getString?.(propName);
            if (p) p.value = String(val);
        };
        const setN = (propName, val) => {
            const p = houseVM.number?.(propName) ?? houseVM.getNumber?.(propName);
            if (p) p.value = Number(val);
        };
        const setE = (propName, val) => {
             const p = houseVM.enum?.(propName) ?? houseVM.getEnum?.(propName);
             if (p && val) {
                 try { p.value = val; } catch (e) { console.warn(`Enum mismatch for ${propName}: ${val}`); }
             }
        };
        
        if (!row) {
             setN('House_Position', 0);
             setS('House_Name', '');
             setN('House_TotalPoints', 0);
             return;
        }

        setN('House_Position', row.position ?? 0);
        setS('House_Name', row.name ?? '');
        setE('HouseIcons', row.name);

        setN('House_LessonAttendance', row.lessonAttendance ?? 0);
        setN('House_HomeworkCompletion', row.homework ?? 0);
        setN('House_ModuleCompletion', row.moduleCompletion ?? 0);
        setN('House_AssessmentSubmission', row.assessmentSubmission ?? 0);
        // REMOVED: House_ManualPoints
        setN('House_TotalPoints', row.score ?? 0);
        
        setS('House_OrientationCompletion', row.orientation ?? "0%");
    }

    // 8.5 Data Writer: Student Panel (and Podium)
    function writeEntry(entryVM, row, fallbackPosition) {
      const setS = (keys, val) => {
          if (!Array.isArray(keys)) keys = [keys];
          for (const k of keys) {
              const p = entryVM.string?.(k) ?? entryVM.getString?.(k);
              if (p) { p.value = String(val); return; }
          }
      };
      const setN = (keys, val) => {
          if (!Array.isArray(keys)) keys = [keys];
          for (const k of keys) {
              const p = entryVM.number?.(k) ?? entryVM.getNumber?.(k);
              if (p) { p.value = Number(val); return; }
          }
      };
      const setE = (keys, val) => {
          if (!Array.isArray(keys)) keys = [keys];
          for (const k of keys) {
              const p = entryVM.enum?.(k) ?? entryVM.getEnum?.(k);
              if (p && val) { 
                  try { p.value = val; return; } catch (e) {} 
              }
          }
      };

      const ps3 = entryVM.enum?.('PointsStatusEnum3') ?? entryVM.getEnum?.('PointsStatusEnum3');
      const statusEnum = entryVM.enum?.('StatusEnum') ?? entryVM.getEnum?.('StatusEnum');

      if (row) {
        setN(['Position', 'StudentPosition'], row.position ?? fallbackPosition ?? 0);
        setS(['Name', 'StudentName', 'HouseName'], row.name ?? '');

        // REMOVED: ManualPoints
        setS('OrientationCompletion', row.orientation ?? ''); 

        if (active === 'houses') {
             setE('HouseIcons', row.name);
             if (ps3) { try { ps3.value = row.name; } catch { } }
        } else {
             if (ps3) { try { ps3.value = getPointsStatusForUser(row?.userId) ?? null; } catch { } }
        }

        if (active === 'points') {
          setN('LessonAttendance', row.lessonAttendance ?? 0);
          setN('ModuleCompletion', row.moduleCompletion ?? 0);
          setN('Homework', row.homework ?? 0);
          setN('AssessmentSubmission', row.assessmentSubmission ?? 0);
          setN(['Score', 'StudentScore'], row.score ?? 0);
          setN('ChangeState', row.change ?? 0);
        
        } else if (active === 'houses') {
          setN(['LessonAttendance', 'House_LessonAttendance'], row.lessonAttendance ?? 0);
          setN(['ModuleCompletion', 'House_ModuleCompletion'], row.moduleCompletion ?? 0);
          setN(['Homework', 'House_HomeworkCompletion'], row.homework ?? 0);
          setN(['AssessmentSubmission', 'House_AssessmentSubmission'], row.assessmentSubmission ?? 0);
          setN(['Score', 'HousePoints', 'Total'], row.score ?? 0);
          setN('ChangeState', 0);

        } else if (active === 'attendance') {
          setN('LessonAttendance', row.attendanceLevel ?? 0);
          setN('ModuleCompletion', row.attendanceDay ?? 0);
          setN(['Homework', 'AssessmentSubmission', 'ChangeState'], 0);
          setN(['Score', 'StudentScore'], row.attendanceDay ?? 0);
        
        } else if (active === 'homework') {
          setN('Homework', row.homeworkLevel ?? 0);
          setN('AssessmentSubmission', row.homeworkDay ?? 0);
          setN(['LessonAttendance', 'ModuleCompletion', 'ChangeState'], 0);
          setN(['Score', 'StudentScore'], row.homeworkDay ?? 0);
        }

        setS('Status', row.status || '');
        if (statusEnum) {
            if (active === 'houses') {
                try { statusEnum.value = null; } catch { }
            } else if (active === 'points') {
                try { statusEnum.value = 'Points'; } catch { }
            } else {
                const v = (row.status || '').trim();
                if (['On Track', 'Streak Warning', 'Level Reset'].includes(v)) {
                   try { statusEnum.value = v; } catch { }
                }
            }
        }

      } else {
        if (ps3) { try { ps3.value = null; } catch { } }
        // REMOVED: ManualPoints from cleanup list
        setN(['Position', 'Score', 'ChangeState', 'LessonAttendance', 'ModuleCompletion', 'Homework', 'AssessmentSubmission'], 0);
        setS(['Name', 'HouseName', 'Status', 'OrientationCompletion'], '');
      }
    }

    // 8.6 Data Writer: Student Panel (The "Me" Card)
    function writeStudentEverywhere(row) {
      const tries = [];
      tries.push(studentVM);
      tries.push((typeof r.viewModelInstance === 'function' ? r.viewModelInstance('Student') : r.viewModelInstance) || null);
      tries.push(r.contents?.viewModel?.('Student')?.instance?.() || null);
      const ui = vm1?.viewModel?.('UserInfo') || vm1?.getViewModel?.('UserInfo');
      tries.push(ui?.viewModel?.('Student') || ui?.getViewModel?.('Student') || null);
      const uniq = [...new Set(tries.filter(Boolean))];
      for (const inst of uniq) writeStudent(inst, row);
    }

    function writeStudent(svm, row) {
      if (!svm) return;

      const sName = svm.string?.('StudentName') ?? svm.getString?.('StudentName');
      const sHouse = svm.string?.('HouseName') ?? svm.getString?.('HouseName'); 
      const sPos = svm.number?.('StudentPosition') ?? svm.getNumber?.('StudentPosition');
      const sChange = svm.number?.('StudentChange') ?? svm.getNumber?.('StudentChange'); 
      const sScore = svm.number?.('StudentScore') ?? svm.getNumber?.('StudentScore');
      const sStatus = svm.string?.('Status') ?? svm.getString?.('Status');
      const ps2 = svm.enum?.('PointsStatusEnum2') ?? svm.getEnum?.('PointsStatusEnum2');
      const sStatusEnum = svm.enum?.('StatusEnum') ?? svm.getEnum?.('StatusEnum');

      if (!row) {
        if (sName) sName.value = '';
        if (sHouse) sHouse.value = '';
        if (sPos) sPos.value = 0;
        if (sChange) sChange.value = 0;
        if (sScore) sScore.value = 0;
        if (sStatus) sStatus.value = '';
        if (ps2) try { ps2.value = null; } catch {}
        return;
      }

      if (sName) sName.value = row.name ?? '';
      if (sHouse) sHouse.value = row.house ?? ''; 
      
      // Use calculated Position
      if (sPos) sPos.value = row.position || 0;
      
      if (sChange) sChange.value = row.change ?? 0;

      if (ps2) { 
          try { ps2.value = normalizePointsStatus(row.status) ?? null; } catch { } 
      }

      if (active === 'points') {
        if (sScore) sScore.value = row.score ?? 0;
      } else if (active === 'attendance') {
        if (sScore) sScore.value = row.attendanceLevel ?? 0;
      } else if (active === 'homework') {
        if (sScore) sScore.value = row.homeworkLevel ?? 0;
      }

      const sv = (row.status || '').trim();
      if (sStatus) sStatus.value = sv;

      if (sStatusEnum && active !== 'points') {
        if (sv === 'On Track' || sv === 'Streak Warning' || sv === 'Level Reset') {
          try { sStatusEnum.value = sv; } catch { }
        }
      } else if (sStatusEnum && active === 'points') {
        try { sStatusEnum.value = null; } catch { }
      }
      
      const id = getOktaIdentity();
      if (row.email && id.email && row.email === id.email && id.fullName && sName) {
        sName.value = id.fullName;
      }
    }

    /* =======================================================================
       9.0 INTERACTION & STATE LOGIC
       ======================================================================= */

    // Reads current tab state from Rive boolean inputs
    function readModeFromBooleans(verbose = false) {
      const getB = (k) => {
        const b = (vm1?.boolean?.(k) ?? vm1?.getBoolean?.(k));
        return b && 'value' in b ? !!b.value : false;
      };
      const p = getB('isPoints');
      const a = getB('isAttendance');
      const h = getB('isHomework');
      const houseMode = getB('isHouses'); 

      // Priority: Houses > Points > Attendance > Homework
      if (houseMode) return 'houses';
      if (p) return 'points';
      if (a) return 'attendance';
      if (h) return 'homework';
      
      return 'points'; // Default Fallback
    }

    function setStudentPointsVsStreaks(isPointsMode) {
      const tries = [];
      tries.push(studentVM);
      tries.push((typeof r.viewModelInstance === 'function' ? r.viewModelInstance('Student') : r.viewModelInstance) || null);
      tries.push(r.contents?.viewModel?.('Student')?.instance?.() || null);
      const ui = vm1?.viewModel?.('UserInfo') || vm1?.getViewModel?.('UserInfo');
      tries.push(ui?.viewModel?.('Student') || ui?.getViewModel?.('Student') || null);
      const uniq = [...new Set(tries.filter(Boolean))];
      for (const inst of uniq) {
        const prop = inst?.boolean?.('PointsvsStreaks') ?? inst?.getBoolean?.('PointsvsStreaks');
        if (prop && 'value' in prop) prop.value = !!isPointsMode;
      }
    }

    // Triggers mode switch (View Refresh + Pagination Reset)
    function setMode(which, { resetPage }) {
      active = which;
      setStudentPointsVsStreaks(active == 'points');

      const ds = datasets[active];
      if (!ds) { console.warn('[MODE] unknown dataset', which); return; }

      ds.pages = computeTotalPages(ds.rows.length);
      pageIndex = resetPage ? 0 : Math.min(pageIndex, ds.pages - 1);

      // Render Podium (Heroes 1-3)
      // Note: renderHero was deprecated in favor of including this logic in renderTable
      // We call renderTable to handle both List and Podium
      
      const preferUserId = getPreferredUserId();
      let rowForPanels = pickRowByUserStrict(ds, preferUserId);
      if (!rowForPanels) rowForPanels = synthesizeUserRow(preferUserId);
      
      writeStudentEverywhere(rowForPanels);

      writePageNumbers(ds.pages);
      renderTable(ds.rows); 
      firePlay();
    }

    function goPage(delta) {
      const ds = datasets[active];
      const next = Math.min(Math.max(pageIndex + delta, 0), ds.pages - 1);
      if (next === pageIndex) return;
      pageIndex = next;
      writePageNumbers(ds.pages);
      renderTable(ds.rows);
      firePlay();
    }

    function writePageNumbers(totalPages) {
      const pi = vm1?.number?.('PageIndex') ?? vm1?.getNumber?.('PageIndex');
      const tp = vm1?.number?.('TotalPages') ?? vm1?.getNumber?.('TotalPages');
      if (pi) pi.value = pageIndex + 1;
      if (tp) tp.value = totalPages;
    }

    function firePlay() {
      const play = vm1?.trigger?.('Play') || vm1?.getTrigger?.('Play');
      if (play?.trigger) play.trigger();
      else if (play?.fire) play.fire();
    }

    function setLoaded(flag) {
      const b = vm1?.boolean?.('isLoaded') ?? vm1?.getBoolean?.('isLoaded');
      if (b && 'value' in b) b.value = !!flag;
    }
  </script>
</body>
</html>